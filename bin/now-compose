#!/usr/bin/env node

// App
const run = require('../lib/cli')
const { version } = require('../package')
const errors = require('../lib/errors')

// Deps
const arg = require('arg')
const commandExists = require('command-exists')

const processArgs = process.argv.slice(2)

const args = arg(
  {
    '--help': Boolean,
    '--file': String,
    '--version': Boolean,

    '-h': '--help',
    '-f': '--file',
    '-v': '--version'
  },
  {
    argv: processArgs,
    permissive: true
  }
)

// the first argument passed is the command to run
const command = processArgs.shift()
const { '--help': showHelp, '--version': showVersion } = args

// if no command is passed in show help screen
if (showHelp || !command) {
  console.log(`
    Description
      Docker compose for zeit/now.
    Usage
      $ now-compose <now-compose command || docker-compose command>
    Now Compose Commands
      up                    Run docker-compose "up" command. Host names for linked
                            services will be passed in environment variables to
                            docker containers.

      deploy                Deploy your project to zeit/now.

    Docker Compose Commands
      now-compose forwards all other commands to docker-compose with any arguments
      you have defined. Please refer to https://docs.docker.com/compose/reference/overview/.

    Options
      --file, -f            A .yaml file not in the current directory which contains
                            the now-compose configuration.

      --version, -v         Displays app version.

      --help, -h            Displays this message.
  `)

  process.exit(0)
}

if (showVersion) {
  console.log(`
    version: ${version}
  `)

  process.exit(0)
}

if (args[command]) {
  console.log(`
    No commands specified to run. Exiting...
  `)

  process.exit(0)
}

;(async () => {
  try {
    try {
      await commandExists('docker-compose')
    } catch (_) {
      console.log(errors.dockerComposeNotInstalled())
      process.exit(1)
    }

    await run(command, args)
  } catch (err) {
    console.log(errors.general(err))
    process.exit(1)
  }
})()
